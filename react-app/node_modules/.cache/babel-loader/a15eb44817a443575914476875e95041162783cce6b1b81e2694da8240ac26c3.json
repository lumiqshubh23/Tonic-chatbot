{"ast":null,"code":"import kleur from 'kleur';\nimport * as diff from 'diff';\nconst colors = {\n  '--': kleur.red,\n  '··': kleur.grey,\n  '++': kleur.green\n};\nconst TITLE = kleur.dim().italic;\nconst TAB = kleur.dim('→'),\n  SPACE = kleur.dim('·'),\n  NL = kleur.dim('↵');\nconst LOG = (sym, str) => colors[sym](sym + PRETTY(str)) + '\\n';\nconst LINE = (num, x) => kleur.dim('L' + String(num).padStart(x, '0') + ' ');\nconst PRETTY = str => str.replace(/[ ]/g, SPACE).replace(/\\t/g, TAB).replace(/(\\r?\\n)/g, NL);\nfunction line(obj, prev, pad) {\n  let char = obj.removed ? '--' : obj.added ? '++' : '··';\n  let arr = obj.value.replace(/\\r?\\n$/, '').split('\\n');\n  let i = 0,\n    tmp,\n    out = '';\n  if (obj.added) out += colors[char]().underline(TITLE('Expected:')) + '\\n';else if (obj.removed) out += colors[char]().underline(TITLE('Actual:')) + '\\n';\n  for (; i < arr.length; i++) {\n    tmp = arr[i];\n    if (tmp != null) {\n      if (prev) out += LINE(prev + i, pad);\n      out += LOG(char, tmp || '\\n');\n    }\n  }\n  return out;\n}\n\n// TODO: want better diffing\n//~> complex items bail outright\nexport function arrays(input, expect) {\n  let arr = diff.diffArrays(input, expect);\n  let i = 0,\n    j = 0,\n    k = 0,\n    tmp,\n    val,\n    char,\n    isObj,\n    str;\n  let out = LOG('··', '[');\n  for (; i < arr.length; i++) {\n    char = (tmp = arr[i]).removed ? '--' : tmp.added ? '++' : '··';\n    if (tmp.added) {\n      out += colors[char]().underline(TITLE('Expected:')) + '\\n';\n    } else if (tmp.removed) {\n      out += colors[char]().underline(TITLE('Actual:')) + '\\n';\n    }\n    for (j = 0; j < tmp.value.length; j++) {\n      isObj = tmp.value[j] && typeof tmp.value[j] === 'object';\n      val = stringify(tmp.value[j]).split(/\\r?\\n/g);\n      for (k = 0; k < val.length;) {\n        str = '  ' + val[k++] + (isObj ? '' : ',');\n        if (isObj && k === val.length && j + 1 < tmp.value.length) str += ',';\n        out += LOG(char, str);\n      }\n    }\n  }\n  return out + LOG('··', ']');\n}\nexport function lines(input, expect, linenum = 0) {\n  let i = 0,\n    tmp,\n    output = '';\n  let arr = diff.diffLines(input, expect);\n  let pad = String(expect.split(/\\r?\\n/g).length - linenum).length;\n  for (; i < arr.length; i++) {\n    output += line(tmp = arr[i], linenum, pad);\n    if (linenum && !tmp.removed) linenum += tmp.count;\n  }\n  return output;\n}\nexport function chars(input, expect) {\n  let arr = diff.diffChars(input, expect);\n  let i = 0,\n    output = '',\n    tmp;\n  let l1 = input.length;\n  let l2 = expect.length;\n  let p1 = PRETTY(input);\n  let p2 = PRETTY(expect);\n  tmp = arr[i];\n  if (l1 === l2) {\n    // no length offsets\n  } else if (tmp.removed && arr[i + 1]) {\n    let del = tmp.count - arr[i + 1].count;\n    if (del == 0) {\n      // wash~\n    } else if (del > 0) {\n      expect = ' '.repeat(del) + expect;\n      p2 = ' '.repeat(del) + p2;\n      l2 += del;\n    } else if (del < 0) {\n      input = ' '.repeat(-del) + input;\n      p1 = ' '.repeat(-del) + p1;\n      l1 += -del;\n    }\n  }\n  output += direct(p1, p2, l1, l2);\n  if (l1 === l2) {\n    for (tmp = '  '; i < l1; i++) {\n      tmp += input[i] === expect[i] ? ' ' : '^';\n    }\n  } else {\n    for (tmp = '  '; i < arr.length; i++) {\n      tmp += (arr[i].added || arr[i].removed ? '^' : ' ').repeat(Math.max(arr[i].count, 0));\n      if (i + 1 < arr.length && (arr[i].added && arr[i + 1].removed || arr[i].removed && arr[i + 1].added)) {\n        arr[i + 1].count -= arr[i].count;\n      }\n    }\n  }\n  return output + kleur.red(tmp);\n}\nexport function direct(input, expect, lenA = String(input).length, lenB = String(expect).length) {\n  let gutter = 4;\n  let lenC = Math.max(lenA, lenB);\n  let typeA = typeof input,\n    typeB = typeof expect;\n  if (typeA !== typeB) {\n    gutter = 2;\n    let delA = gutter + lenC - lenA;\n    let delB = gutter + lenC - lenB;\n    input += ' '.repeat(delA) + kleur.dim(`[${typeA}]`);\n    expect += ' '.repeat(delB) + kleur.dim(`[${typeB}]`);\n    lenA += delA + typeA.length + 2;\n    lenB += delB + typeB.length + 2;\n    lenC = Math.max(lenA, lenB);\n  }\n  let output = colors['++']('++' + expect + ' '.repeat(gutter + lenC - lenB) + TITLE('(Expected)')) + '\\n';\n  return output + colors['--']('--' + input + ' '.repeat(gutter + lenC - lenA) + TITLE('(Actual)')) + '\\n';\n}\nexport function sort(input, expect) {\n  var k,\n    i = 0,\n    tmp,\n    isArr = Array.isArray(input);\n  var keys = [],\n    out = isArr ? Array(input.length) : {};\n  if (isArr) {\n    for (i = 0; i < out.length; i++) {\n      tmp = input[i];\n      if (!tmp || typeof tmp !== 'object') out[i] = tmp;else out[i] = sort(tmp, expect[i]); // might not be right\n    }\n  } else {\n    for (k in expect) keys.push(k);\n    for (; i < keys.length; i++) {\n      if (Object.prototype.hasOwnProperty.call(input, k = keys[i])) {\n        if (!(tmp = input[k]) || typeof tmp !== 'object') out[k] = tmp;else out[k] = sort(tmp, expect[k]);\n      }\n    }\n    for (k in input) {\n      if (!out.hasOwnProperty(k)) {\n        out[k] = input[k]; // expect didnt have\n      }\n    }\n  }\n  return out;\n}\nexport function circular() {\n  var cache = new Set();\n  return function print(key, val) {\n    if (val === void 0) return '[__VOID__]';\n    if (typeof val === 'number' && val !== val) return '[__NAN__]';\n    if (typeof val === 'bigint') return val.toString();\n    if (!val || typeof val !== 'object') return val;\n    if (cache.has(val)) return '[Circular]';\n    cache.add(val);\n    return val;\n  };\n}\nexport function stringify(input) {\n  return JSON.stringify(input, circular(), 2).replace(/\"\\[__NAN__\\]\"/g, 'NaN').replace(/\"\\[__VOID__\\]\"/g, 'undefined');\n}\nexport function compare(input, expect) {\n  if (Array.isArray(expect) && Array.isArray(input)) return arrays(input, expect);\n  if (expect instanceof RegExp) return chars('' + input, '' + expect);\n  let isA = input && typeof input == 'object';\n  let isB = expect && typeof expect == 'object';\n  if (isA && isB) input = sort(input, expect);\n  if (isB) expect = stringify(expect);\n  if (isA) input = stringify(input);\n  if (expect && typeof expect == 'object') {\n    input = stringify(sort(input, expect));\n    expect = stringify(expect);\n  }\n  isA = typeof input == 'string';\n  isB = typeof expect == 'string';\n  if (isA && /\\r?\\n/.test(input)) return lines(input, '' + expect);\n  if (isB && /\\r?\\n/.test(expect)) return lines('' + input, expect);\n  if (isA && isB) return chars(input, expect);\n  return direct(input, expect);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}