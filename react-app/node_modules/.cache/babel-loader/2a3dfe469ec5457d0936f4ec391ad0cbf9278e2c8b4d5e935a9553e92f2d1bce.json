{"ast":null,"code":"import { dequal } from 'dequal';\nimport { compare, lines } from 'uvu/diff';\nfunction dedent(str) {\n  str = str.replace(/\\r?\\n/g, '\\n');\n  let arr = str.match(/^[ \\t]*(?=\\S)/gm);\n  let i = 0,\n    min = 1 / 0,\n    len = (arr || []).length;\n  for (; i < len; i++) min = Math.min(min, arr[i].length);\n  return len && min ? str.replace(new RegExp(`^[ \\\\t]{${min}}`, 'gm'), '') : str;\n}\nexport class Assertion extends Error {\n  constructor(opts = {}) {\n    super(opts.message);\n    this.name = 'Assertion';\n    this.code = 'ERR_ASSERTION';\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    this.details = opts.details || false;\n    this.generated = !!opts.generated;\n    this.operator = opts.operator;\n    this.expects = opts.expects;\n    this.actual = opts.actual;\n  }\n}\nfunction assert(bool, actual, expects, operator, detailer, backup, msg) {\n  if (bool) return;\n  let message = msg || backup;\n  if (msg instanceof Error) throw msg;\n  let details = detailer && detailer(actual, expects);\n  throw new Assertion({\n    actual,\n    expects,\n    operator,\n    message,\n    details,\n    generated: !msg\n  });\n}\nexport function ok(val, msg) {\n  assert(!!val, false, true, 'ok', false, 'Expected value to be truthy', msg);\n}\nexport function is(val, exp, msg) {\n  assert(val === exp, val, exp, 'is', compare, 'Expected values to be strictly equal:', msg);\n}\nexport function equal(val, exp, msg) {\n  assert(dequal(val, exp), val, exp, 'equal', compare, 'Expected values to be deeply equal:', msg);\n}\nexport function unreachable(msg) {\n  assert(false, true, false, 'unreachable', false, 'Expected not to be reached!', msg);\n}\nexport function type(val, exp, msg) {\n  let tmp = typeof val;\n  assert(tmp === exp, tmp, exp, 'type', false, `Expected \"${tmp}\" to be \"${exp}\"`, msg);\n}\nexport function instance(val, exp, msg) {\n  let name = '`' + (exp.name || exp.constructor.name) + '`';\n  assert(val instanceof exp, val, exp, 'instance', false, `Expected value to be an instance of ${name}`, msg);\n}\nexport function match(val, exp, msg) {\n  if (typeof exp === 'string') {\n    assert(val.includes(exp), val, exp, 'match', false, `Expected value to include \"${exp}\" substring`, msg);\n  } else {\n    assert(exp.test(val), val, exp, 'match', false, `Expected value to match \\`${String(exp)}\\` pattern`, msg);\n  }\n}\nexport function snapshot(val, exp, msg) {\n  val = dedent(val);\n  exp = dedent(exp);\n  assert(val === exp, val, exp, 'snapshot', lines, 'Expected value to match snapshot:', msg);\n}\nconst lineNums = (x, y) => lines(x, y, 1);\nexport function fixture(val, exp, msg) {\n  val = dedent(val);\n  exp = dedent(exp);\n  assert(val === exp, val, exp, 'fixture', lineNums, 'Expected value to match fixture:', msg);\n}\nexport function throws(blk, exp, msg) {\n  if (!msg && typeof exp === 'string') {\n    msg = exp;\n    exp = null;\n  }\n  try {\n    blk();\n    assert(false, false, true, 'throws', false, 'Expected function to throw', msg);\n  } catch (err) {\n    if (err instanceof Assertion) throw err;\n    if (typeof exp === 'function') {\n      assert(exp(err), false, true, 'throws', false, 'Expected function to throw matching exception', msg);\n    } else if (exp instanceof RegExp) {\n      assert(exp.test(err.message), false, true, 'throws', false, `Expected function to throw exception matching \\`${String(exp)}\\` pattern`, msg);\n    }\n  }\n}\n\n// ---\n\nexport function not(val, msg) {\n  assert(!val, true, false, 'not', false, 'Expected value to be falsey', msg);\n}\nnot.ok = not;\nis.not = function (val, exp, msg) {\n  assert(val !== exp, val, exp, 'is.not', false, 'Expected values not to be strictly equal', msg);\n};\nnot.equal = function (val, exp, msg) {\n  assert(!dequal(val, exp), val, exp, 'not.equal', false, 'Expected values not to be deeply equal', msg);\n};\nnot.type = function (val, exp, msg) {\n  let tmp = typeof val;\n  assert(tmp !== exp, tmp, exp, 'not.type', false, `Expected \"${tmp}\" not to be \"${exp}\"`, msg);\n};\nnot.instance = function (val, exp, msg) {\n  let name = '`' + (exp.name || exp.constructor.name) + '`';\n  assert(!(val instanceof exp), val, exp, 'not.instance', false, `Expected value not to be an instance of ${name}`, msg);\n};\nnot.snapshot = function (val, exp, msg) {\n  val = dedent(val);\n  exp = dedent(exp);\n  assert(val !== exp, val, exp, 'not.snapshot', false, 'Expected value not to match snapshot', msg);\n};\nnot.fixture = function (val, exp, msg) {\n  val = dedent(val);\n  exp = dedent(exp);\n  assert(val !== exp, val, exp, 'not.fixture', false, 'Expected value not to match fixture', msg);\n};\nnot.match = function (val, exp, msg) {\n  if (typeof exp === 'string') {\n    assert(!val.includes(exp), val, exp, 'not.match', false, `Expected value not to include \"${exp}\" substring`, msg);\n  } else {\n    assert(!exp.test(val), val, exp, 'not.match', false, `Expected value not to match \\`${String(exp)}\\` pattern`, msg);\n  }\n};\nnot.throws = function (blk, exp, msg) {\n  if (!msg && typeof exp === 'string') {\n    msg = exp;\n    exp = null;\n  }\n  try {\n    blk();\n  } catch (err) {\n    if (typeof exp === 'function') {\n      assert(!exp(err), true, false, 'not.throws', false, 'Expected function not to throw matching exception', msg);\n    } else if (exp instanceof RegExp) {\n      assert(!exp.test(err.message), true, false, 'not.throws', false, `Expected function not to throw exception matching \\`${String(exp)}\\` pattern`, msg);\n    } else if (!exp) {\n      assert(false, true, false, 'not.throws', false, 'Expected function not to throw', msg);\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}